#### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

难度简单

给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。 

**示例 1：**

```
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 2：**

```
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 3：**

```
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```

**示例 4：**

```
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 104`
- `0 <= nums[i] <= n`
- `nums` 中的所有数字都 **独一无二**

 

**进阶：**你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?



11-6 的每日一题，这个题目比较简单

简单思路，首先对数组进行排序，然后对`nums[i]`和`i`进行比较，代码

```go
func missingNumber(nums []int) int {
	sort.Ints(nums)
	for i,num := range nums {
		if i != num {
			return i
		}
	}
	return len(nums)
}
```

代码提交，这个方式，代码实现简单，但是速度较慢

![image-20211107002022356](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211107002022356.png)

我们换一个方法，这个方法的时间复杂度是排序的时间复杂度，也就是`O(NlogN)`，我们可以将时间复杂度优化到`O(N)`，这种方式其实很简单，我们可以使用一个数组来保存每个数组出现的状态

```go
func missingNumber(nums []int) int {
	length := len(nums)
	flags := make([]bool,length+1)
	for _, num := range nums {
		flags[num] = true
	}
	for i, flag := range flags {
		if !flag {
			return i
		}
	}
	return length
}
```



提交，时间复杂度得到明显优化

![image-20211107002834574](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211107002834574.png)

这种方式的时间复杂度为`O(N)`

题目进阶要求该题的空间复杂度为`O(1)`

如何处理才可以将空间复杂度优化到`O(1)`呢？递增数列求和的

数组之和为 `n * (n + 1 ) /2`，这个是高中数学

```go
func missingNumber(nums []int) int {
   length := len(nums)
   sum := length * (length - 1) / 2
   for _, num := range nums {
      sum -= num
   }
   return sum
}
```

我们可以看到时间复杂度和空间复杂度有了明显的优化

![image-20211107003709264](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211107003709264.png)