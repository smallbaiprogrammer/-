#### [66. 加一](https://leetcode-cn.com/problems/plus-one/)

难度简单 

给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

 

**示例 1：**

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

**示例 2：**

```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

**示例 3：**

```
输入：digits = [0]
输出：[1]
```

 

**提示：**

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`



这个题是大概看一下，基本就可以用两种思路的

#### 方案一

将这个数字转换为一种编程语言内置的可以进行计算的形式，这个题的规定了这个数组的最大长度可以达到100，我们可以将这个数组转为字符串，然后转为`bigDecimal`大数的形式进行计算，然后计算完毕之后，再将这个大数转为字符串的形式，然后再转为数字的形式

这种操作没有什么难度，但是速度太慢了，因为需要两次对数组进行全遍历操作，这种操作太蠢了我就不写了



#### 方案二

实现一个简单的加法器，这种思路很简单，代码如下，包含讲解，这里采用`go`语言实现

```go
func plusOne(digits []int) []int {
   //  定义 进位  
    //  加一  相当于  最低位有一个值为 1 的 进位
   carry := 1
      // 倒叙遍历数组    最右边是最低位
   for i := len(digits) - 1; i >= 0; i-- {
       //  将进位 和 本身的值相加  
      temp := carry + digits[i]
       //  获取进位
      carry = temp/10
       // 除去进位之后，本身剩余的值
      digits[i] = temp% 10
   }
   // 如果数组遍历完成，进位值依然不为0，那么就需要设置一个更高位
   if carry != 0 {
       // 数组前面插入最高位  值为 进位的值
      digits = append([]int{carry},digits...)
   }
   return digits
}
```

提交测试

![image-20211022001014892](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211022001014892.png)

只有俩字能表达我的感受

![image-20211022001110552](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211022001110552.png)



这个题太简单了，我们做一个类似的题，这个题只是简单的加一，用的是加法器的思想，所以干脆不如直接下一个加法器的问题

#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

难度中等

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

 

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零



具体如何去做，同样也是分两种方法，一个是转化为字符串，然后转为大数类，进行计算，然后逆向转化，第二种加法器，不建议用第一种方法，因为太捞了，也有可能超时

这个题使用的`javascript`写的解题过程

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
// 输入两个链表的头节点 
var addTwoNumbers = function(l1, l2) {
    			// 定义索引
                let head = null,tail = null;
                let carry = 0;
    			// 两个节点均为null 值时，退出计算
                while (l1 || l2 ){
                    // 如果当前节点为空，那么此时的值为 0 
                    const n1 = l1 ? l1.val : 0;
                    const n2 = l2 ? l2.val : 0;
                    // 计算当前的值
                    const sum = n1 + n2 + carry;
                    // 设置节点
                    //  如果为头节点，直接赋值
                    //  否则为下一个节点赋值，一直迭代，这种思路不是最好的，可以直接使用递归的仔细，为后面的节点赋值，知道头节点
                    if (!head){
                        head = tail = new ListNode(sum % 10);
                    }else {
                        tail.next = new ListNode(sum % 10);
                        tail = tail.next;
                    }
                    //  计算进位值
                    carry = Math.floor(sum / 10);
                    // 如果当前节点为空，就不动，如果不为空则索引移动
                    if (l1){
                        l1 = l1.next;
                    }
                    if (l2){
                        l2 = l2.next;
                    }
                }
    // 同样如果，两条链表都遍历完成，进位不等于 0，新增一个节点
                if (carry > 0){
                    tail.next = new ListNode(carry);
                }
                return head;
            };
```

这道题的难度非常适合刚开始刷题的新生练手用，技能熟悉链表的结构，又能了解递归的思路。

加油打工人，今天结束

![image-20211022002358506](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211022002358506.png)



