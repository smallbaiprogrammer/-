#### [492. 构造矩形](https://leetcode-cn.com/problems/construct-the-rectangle/)

难度简单95

作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：

```
1. 你设计的矩形页面必须等于给定的目标面积。

2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。

3. 长度 L 和宽度 W 之间的差距应当尽可能小。
```

你需要按顺序输出你设计的页面的长度 L 和宽度 W。

**示例：**

```
输入: 4
输出: [2, 2]
解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。
但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。
```

**说明:**

1. 给定的面积不大于 10,000,000 且为正整数。
2. 你设计的页面的长度和宽度必须都是正整数。



这个题属于简单题，仔细读完题，思路就是去试，从根号`area`试到 1 

代码实现如下

``` go
func constructRectangle(area int) (ans []int) {
    //  求平方根
	sqrt := int(math.Sqrt(float64(area)))
	for area % sqrt != 0 {
		sqrt --
	}
	ans = append(ans,area/sqrt)
	ans = append(ans,sqrt)
	return 
}
```

提交，我们发现

![image-20211023205718726](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211023205718726.png)

居然通过了而且运行速度还超过百分之百的用户，怎么可以这么简单

![image-20211023210105027](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211023210105027.png)

那好我们再做一个没有试过的题目 

#### [1405. 最长快乐字符串](https://leetcode-cn.com/problems/longest-happy-string/)

难度中等

如果字符串中不含有任何 `'aaa'`，`'bbb'` 或 `'ccc'` 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。

给你三个整数 `a`，`b` ，`c`，请你返回 **任意一个** 满足下列全部条件的字符串 `s`：

- `s` 是一个尽可能长的快乐字符串。
- `s` 中 **最多** 有`a` 个字母 `'a'`、`b` 个字母 `'b'`、`c` 个字母 `'c'` 。
- `s `中只含有 `'a'`、`'b'` 、`'c'` 三种字母。

如果不存在这样的字符串 `s` ，请返回一个空字符串 `""`。

 

**示例 1：**

```
输入：a = 1, b = 1, c = 7
输出："ccaccbcc"
解释："ccbccacc" 也是一种正确答案。
```

**示例 2：**

```
输入：a = 2, b = 2, c = 1
输出："aabbc"
```

**示例 3：**

```
输入：a = 7, b = 1, c = 0
输出："aabaa"
解释：这是该测试用例的唯一正确答案。
```

 

**提示：**

- `0 <= a, b, c <= 100`
- `a + b + c > 0`



这道题在2021届校招考试中特别火，据说字节面试的时候必写的一个题，这个题在牛客网也是特别的火爆，所以掌握这道题显示很重要。

##### 有一说一这道题在我进行字节跳动二面的时候被面试官问过，这道题没见过，而且对这个题的算法也不是特别熟悉，所以当时想了好久，赶紧要凉了突然就上头了，我就写出来了居然还通过了，只觉得自己当时超级`nb`，只不过二面还是挂了，自我感觉应该因为项目经验欠缺的缘故，面试时吹`nb`，比谁都遛，到底干了啥具体的事，没啥把握不敢说，都是一些上不得台面的项目，所以这更体现了大厂对项目经验的要求还是蛮高的

不多`bb`，先看一下，我在面试时写的代码，因为面试的Java后端，所有Java实现的，现在自己看这段代码，就两字，垃圾。不知道那个垃圾写出来的垃圾代码

![image-20211023211407018](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211023211407018.png)

还是看看代码吧

```java
class Solution {
    public String longestDiverseString(int a, int b, int c) {
        //  构建最长快乐字符串
        StringBuilder sb = new StringBuilder();
        while (true){
            //  构建字符串当前的字符，如果字符为空，选择一个额外的字符 d
            char temp = sb.length() == 0 ? 'd' : sb.charAt(sb.length()-1);
            // 当前字符出现的次数
            int count = 1;
            // 对当前字符进行计数 ，如果
            if (sb.length() >= 2 && sb.charAt(sb.length() - 2) == temp){
                count ++;
            }
            
            //  然后找出abc中最大的值，第二大的值，最小的值
            //  最好可以先放入剩余最多的值，这样可以保证字符串相对更长一点
            //  当剩余最多的值已经出现了两次，就放入第二多的字符
            // 每次放完 重新比较 
            //  当就只剩下一种字符还没有放完，并且字符串的最后两个字符是这个剩余的字符，那么循环结束
            //  以下所有代码都是为了实现上述三句话 
            int max = Math.max(a,Math.max(b,c));
            if (max <= 0){
                break;
            }
            if (max == a ){
                if (temp != 'a' || count < 2){
                    sb.append('a');
                    a--;
                }else {
                    int secMax = Math.max(b,c);
                    if (secMax <= 0){
                        break;
                    }
                    if (b == secMax){
                        sb.append('b');
                        b--;
                    }else {
                        c--;
                        sb.append('c');
                    }
                }

            }else if (max == b ){
                if (temp != 'b' || count < 2 ){
                    sb.append('b');
                    b--;
                }else {
                    int secMax = Math.max(a,c);
                    if (secMax <= 0){
                        break;
                    }
                    if (a == secMax){
                        sb.append('a');
                        a--;
                    }else {
                        c--;
                        sb.append('c');
                    }
                }

            }else {
                if (temp != 'c' || count < 2){
                    sb.append('c');
                    c--;
                }else {
                    int secMax = Math.max(a,b);
                    if (secMax <= 0){
                        break;
                    }
                    if (a == secMax){
                        a--;
                        sb.append('a');
                    }else {
                        b--;
                        sb.append('b');
                    }
                }
            }
        }
        return sb.toString();
    }
}
```

看到这么多`if else`，肯定是垃圾代码了，但是当时面试没想那么多，能运行就是王道，

![image-20211023212246719](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211023212246719.png)

结果运行真特么的成功了，当时面试官都懵了，想的肯定是这个傻逼写的傻逼代码居然运行成功了，而且跑的还特么挺快，真是 小母牛坐火箭，牛逼上天了，好像 拿着小刀刺屁股，真是开了眼

果然速度快的代码，只需要简单`ifelse`操作

#### 当然作为一个优雅的程序员是不允许自己写出这么垃圾的代码，所以今天要对这些代码进行重构

总体思路不变，采用贪心算法的思路

```go
// 首先创建一个结构体，将字符数量和字符绑定起来
type Pair struct {
   char rune
   count int
}
func longestDiverseString(a int, b int, c int) string {
   //  实例化这个结构，将字符 和 数量绑定起来
   arr := []*Pair{
      {char: 'a',count: a},
      {char: 'b',count: b},
      {char: 'c',count: c},
   }
   //  声明 存放字符的位置
   var buf bytes.Buffer
   // 声明前两个字符保存的内容
   var first,second rune
   for true {
      // 根据出现次数进行排序
      sort.Slice(arr, func(i, j int) bool {
         return arr[i].count < arr[j].count
      })
      //  为什么采用 pair 指针，而不是采用 rune 字符的形式，后面揭晓
      var p *Pair
      // 贪心：最多连续放置两个最大数
      //  如果出现了连续两个都放出现次数最多的字符 ，放一个次数第二多的字符，然后再进行下面操作
      if first == arr[2].char && second == arr[2].char {
         if arr[1].count > 0 {
            p = arr[1]
         }
         //  如果没有出现就一直放剩余次数最多的字符
      }else if arr[2].count > 0 {
         p = arr[2]
      }
      if p == nil {
         // 如果没有能放置的，退出循环
         break
      }
      //  擦屁股 进行后续处理
      //  将字符写入结果中
      buf.WriteRune(p.char)
      //  减去已经已经用过的次数
      // 这一个 写法非常 漂亮  看到这里 非常妙 ，灵活运用了指针的技巧
      p.count--
      //  最后为，前两个字符进行值的变更
      first,second = second,p.char
   }
   // 返回字符串
   return buf.String()
}
```

这种写法是借鉴`leetcode`排行前几位的一个大佬写的，现在变成我写的了

![image-20211023214752389](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211023214752389.png)

这个代码和我之前的写的相比就是艺术品，大家好好欣赏

![image-20211023215150679](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211023215150679.png)

