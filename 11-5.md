#### [1218. 最长定差子序列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/)

难度中等

给你一个整数数组 `arr` 和一个整数 `difference`，请你找出并返回 `arr` 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 `difference` 。

**子序列** 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 `arr` 派生出来的序列。

 

**示例 1：**

```
输入：arr = [1,2,3,4], difference = 1
输出：4
解释：最长的等差子序列是 [1,2,3,4]。
```

**示例 2：**

```
输入：arr = [1,3,5,7], difference = 1
输出：1
解释：最长的等差子序列是任意单个元素。
```

**示例 3：**

```
输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2
输出：4
解释：最长的等差子序列是 [7,5,3,1]。
```

 

**提示：**

- `1 <= arr.length <= 105`
- `-104 <= arr[i], difference <= 104`



今天的题目，最长定差子序列，今天这个题目最重要的一个点就是子序列的这个概念，在不改变其余元素的顺序的情况下，删除一些元素或不删除任何元素从而`arr`派生出来的序列，这种题目很明显，就是动态规划。

我们只要建一个一维数组`dp[i]`保存从`0 ~ i`中的最长定差子序列

清楚了这个，然后就要搞清楚动态规划的两个变量

第一个起始量，这个题目初始量很简单，数组所有元素都为 1 

第二个就是状态转移方程，这个也比较容易想，当遍历到索引为 `i`时，沿着 `i`向前搜索，找到一个`j`

`dp[i] = dp[j] + 1`，找不到就返回，就返回一

思路写下来了，开始代码

```go
func longestSubsequence(arr []int, difference int) int {
	length := len(arr)
	dp := make([]int,length)
	for i := 0; i < length; i++ {
		dp[i] = 1
	}
	m := 0
	for i := 0; i < length; i++ {
		for j := i - 1; j >= 0; j-- {
			temp := arr[i]
			if temp -difference == arr[j] {
				dp[i] = dp[j] + 1
				break
			}
		}
		m = max(m,dp[i])
	}
	return m
}
func max(x,y int) int {
    if x > y {
        return x 
    }else {
        return y
    }
}
```

但是此时尴尬的事情发生了

![image-20211105213613104](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211105213613104.png)

超时了，倒数第三个用例，超时了

![image-20211105213641498](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211105213641498.png)、

倒数第三个用例是最坏的情况，这个算法的时间复杂度是就变成了 O(n^2^)了

那么我们仔细想想如何优化，将时间变快一点

这一步就该在查找这一块进行查找这一块进行优化，如何找到前一个`dp`所保存的数组，我们只要将存储的值当作索引，我们引用`map`来进行存值，进行查找，这样查询速度就会从O(n)变为O(1)

这就是哈希表的妙处

代码实现

```go
func longestSubsequence(arr []int, difference int) int {
   ans := 1
   dp := map[int]int{}
   for _, num := range arr {
      dp[num] = dp[num - difference] + 1
      if dp[num] > ans {
         ans = dp[num]
      }
   }
   return ans
}
```

这个也是动态规划，只不过使用`map`作为`DP`进行存值

提交代码

![image-20211105215118300](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211105215118300.png)

`ok`速度超过百分百

![image-20211105215904447](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211105215904447.png)



