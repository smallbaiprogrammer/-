### 今天是 10-24，程序员节，过节也要肝代码，

### 奥里给

#### [638. 大礼包](https://leetcode-cn.com/problems/shopping-offers/)

难度中等

在 LeetCode 商店中， 有 `n` 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。

给你一个整数数组 `price` 表示物品价格，其中 `price[i]` 是第 `i` 件物品的价格。另有一个整数数组 `needs` 表示购物清单，其中 `needs[i]` 是需要购买第 `i` 件物品的数量。

还有一个数组 `special` 表示大礼包，`special[i]` 的长度为 `n + 1` ，其中 `special[i][j]` 表示第 `i` 个大礼包中内含第 `j` 件物品的数量，且 `special[i][n]` （也就是数组中的最后一个整数）为第 `i` 个大礼包的价格。

返回 **确切** 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。

 

**示例 1：**

```
输入：price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]
输出：14
解释：有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 
大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 
大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 
需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。
```

**示例 2：**

```
输入：price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]
输出：11
解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。
可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 
需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 
不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。
```

 

**提示：**

- `n == price.length`
- `n == needs.length`
- `1 <= n <= 6`
- `0 <= price[i] <= 10`
- `0 <= needs[i] <= 10`
- `1 <= special.length <= 100`
- `special[i].length == n + 1`
- `0 <= special[i][j] <= 50`



今天这个题也是一个中等的题目，但是其实难度与相对来说更大一点，不过无所谓，首先看一下这个题目，首先声明一下，这个题目我也没有做过

![image-20211024200454917](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211024200454917.png)

这个题类似于一个`背包问题`，但是仔细看来并不是一个完全体的背包问题。简单介绍一下背包问题：

根据[维基百科](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98)，背包问题（Knapsack problem）是一种组合优化的NP完全（NP-Complete，NPC）问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。NPC问题是没有多项式时间复杂度的解法的，但是利用动态规划，我们可以以伪多项式时间复杂度求解背包问题

如果是背包问题，肯定是采用动态规划的方法来进行解题了

首先，我们可以先不采用大礼包的方式，直接根据单价来购买这些物品，计算完毕之后，根据大礼包的优惠，这个购买物品的价格进行优化，但是出现了一个问题，如果后续对这个物品的价格进行优惠，好像需要遍历一遍数组，就是东西总价的数组，那么就需要一个状态转移的过程，因为可能会用到很多大礼包。

举个例子，如果要买两个物品，5个A物品，6个B物品，那么就需要从0个A，0个B到五个A，五个B的过程，全部进行保存，如果是两个物品，这样保存可以，如果是N个物品，难道要用一个N阶数组吗？这显示是现实的。但是无论是采用什么样的方法，必须要是存储这个中间过程量的，我们以何种形式存储，就成为一个难点，不过我们可以试试采用深度优先搜索的方式，将存储的中间值保存在栈中，我们可以试一下，这样写，很大概率上不通过，不过可以试一试

```go
var n int
func shoppingOffers(price []int, special [][]int, needs []int) int {
   n = len(price)
   return dfs0(price,special,needs)
}
func dfs0(price []int, specials [][]int, needs []int) int {
   // 首先计算不使用优惠
   ans := 0
   for i := 0; i < n; i++ {
      ans += price[i] * needs[i]
   }
   // 使用大礼包
   for i := 0; i < len(specials); i++ {
      special := specials[i]
      // 这里采用深拷贝，防止递归过程中，数组中的元素相互干扰
      temp := make([]int,n)
      for i := 0; i < n; i++ {
         temp[i] = needs[i]
      }
      //  判断可以能否使用该大礼包
      flag := false
      for j := 0; j < n; j++ {
         //  如果大礼包的物品超过了所需要的物品，就不用大礼包了
         if temp[j] < special[j] {
            flag = true
            break
         }
         // 如果采用了 大礼包，需求变小
         temp[j] = temp[j] - special[j]
      }
      // 如果使用了这个礼包，则利用需求变小的这个需求和礼包，进行查找
      if !flag {
         ans = min(ans,special[n] + dfs0(price,specials,temp))
      }

   }
   return ans
}
```

`这段代码，采用递归的形式，将中间值，存储在栈中。

可能有人会对这段代码产生疑问，就是在使用礼包的时候，每次都对数组进行从前到后遍历，这样会不会导致都次都会优先使用第一个礼包，导致结果出现问题，这个疑虑非常好，首先一开始我也是这样考虑的，但是其实并不存在这个问题，因为我们采用 最小值取值，就是只有从这些礼包中先选，找到那些礼包可以使用，然后用那个礼包最便宜，而且每次使用礼包的时候都会比较一次，这样就不会产生上述的问题

我们提交一下代码

![image-20211024211418153](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211024211418153.png)

还可以，提交通过了，只是速度有点慢，这个解法其实使用了类似于动态规划的思路，但是其实细看又不属于动态规划，其实是属于贪心算法的范畴，但是在贪心之后我们采用了最佳礼包，但是用了最佳礼包，其他非最佳的礼包的使用依然没有停止，这样是不是浪费了时间呢！

其实不然，因为在使用礼包的过程中，要保证尽可能多的使用礼包，比如，如果第一次使用了最佳礼包，那么第二次有可能无法使用礼包；如果第一次使用非最佳礼包，那么第二次可能还会使用一次非最佳礼包。这样看来这个题的解法还是属于动态规划，但是我们没有保存中间状态，所以啥解法也不算，也就算是暴力破解吧

这个解法是我自己的思路，下面我们看一下官方的解法：

官方解法是采用记忆化搜索的方法，官方解法首先过滤掉了没有优惠大礼包，然后根据根据需求记忆化搜索，那么啥叫记忆化搜索，我们不说的那么nb就简简单单的理解，就是将之前计算过的结果保存起来，下次再用的时候直接用，不要重新计算一次，相当于对我写的解法进行了两个优化；

1. 抛掉不优惠的礼包
2. 将已经计算过的过程进行保存，下次调用不需要重新计算

然后我们根据自己的代码，依赖官方的解法进行修改，第一步很容易修改，但是第二部因为`go`语言中`map`的`key`是不可以为切片（可简单理解为数组）的，所以这里无法仿照官方进行记忆化搜索，当然也是可以不使用`map`类型来保存中间过程，使用数组保存，但是这样性能会查很多，所以先使用第一个优化提交查看，然后根据`java`来实现，查看性能

![image-20211024220023987](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211024220023987.png)

性能提升了一部分，但是区别不打

如果采用记忆化搜索

```java
class Solution {

    int n;

    public int shoppingOffers(List<Integer> price, List<List<Integer>> special, List<Integer> needs) {
        this.n = price.size();
        Map<List<Integer>, Integer> cache = new HashMap<>();
        return dfs(price, special, needs, cache);
    }

    private int dfs(List<Integer> price, List<List<Integer>> special, List<Integer> needs, Map<List<Integer>, Integer> cache) {
        // 查找是否已经出现过 
        if (cache.containsKey(needs)) {
            return cache.get(needs);
        }

        // 不使用大礼包的情况下
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += needs.get(i) * price.get(i);
        }

        // 使用大礼包的情况下
        for (List<Integer> s : special) {
            // 大礼包可以购买无限次
            List<Integer> curr = new ArrayList<>(needs);
            boolean flag = false;
            for (int i = 0; i < n; i++) {
                // 判断是否超出数量限制
                if (curr.get(i) - s.get(i) < 0) {
                    flag = true;
                    break;
                }
                curr.set(i, curr.get(i) - s.get(i));
            }

            // 未超出数量限制
            if (!flag) {
                ans = Math.min(ans, s.get(n) + dfs(price, special, curr, cache));   
            }
        }
		//  查找记录添加到缓存中 
        cache.put(needs, ans);

        return ans;
    }
}

```

大概思路就是这样

