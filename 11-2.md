#### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

难度简单1041

请编写一个函数，用于 **删除单链表中某个特定节点** 。在设计函数时需要注意，你无法访问链表的头节点 `head` ，只能直接访问 **要被删除的节点** 。

题目数据保证需要删除的节点 **不是末尾节点** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/01/node1.jpg)

```
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/01/node2.jpg)

```
输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9
```

**示例 3：**

```
输入：head = [1,2,3,4], node = 3
输出：[1,2,4]
```

**示例 4：**

```
输入：head = [0,1], node = 0
输出：[1]
```

**示例 5：**

```
输入：head = [-3,5,-99], node = -3
输出：[5,-99]
```

 

**提示：**

- 链表中节点的数目范围是 `[2, 1000]`
- `-1000 <= Node.val <= 1000`
- 链表中每个节点的值都是唯一的
- 需要删除的节点 `node` 是 **链表中的一个有效节点** ，且 **不是末尾节点**



今天的题目删除单链表中指定的节点，这个其实还是比较简单的，就是题目感觉好像读不懂，但是读懂了之后，就会发现原来这个题目这么简单啊。

函数中给出的一个链表中的一个节点，要删除这个节点，无法访问这个链表前面的节点

虽然这样也其实还是比较简单的

简单的思路就是将下一个节点的值保存到当前这个节点，然后删除下一个节点

因为在单链表中无法删除当前节点的，因为单链表无法访问当指向自己的指针

```go
func deleteNode(node *ListNode) {
   node.Val = node.Next.Val
   node.Next = node.Next.Next
}
```

提交通过

![image-20211102205604076](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211102205604076.png)

好慢，我们看一下大佬们是如何实现的

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func deleteNode(node *ListNode) {
    p := node
    for p.Next.Next != nil{
        p.Val = p.Next.Val
        p = p.Next
    }
    p.Val = p.Next.Val
    p.Next = nil
}
```

这个大佬是将当前节点后面的每一个节点都前移了一位，将最后一个节点删掉了，没有我们使用的方法好。我们重复提交一下，还是很慢，算了

再看一个链表的题目

#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

难度困难1345

给你一个链表，每 *k* 个节点一组进行翻转，请你返回翻转后的链表。

*k* 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 *k* 的整数倍，那么请将最后剩余的节点保持原有顺序。

**进阶：**

- 你可以设计一个只使用常数额外空间的算法来解决此问题吗？
- **你不能只是单纯的改变节点内部的值**，而是需要实际进行节点交换。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**示例 3：**

```
输入：head = [1,2,3,4,5], k = 1
输出：[1,2,3,4,5]
```

**示例 4：**

```
输入：head = [1], k = 1
输出：[1]
```



**提示：**

- 列表中节点的数量在范围 `sz` 内
- `1 <= sz <= 5000`
- `0 <= Node.val <= 1000`
- `1 <= k <= sz`

#### 要想实现`k`个链表反转，一个链表如何反转呢？

一个单链表反转就很简单了，递归，栈，或者指针操作

```go
func reverseList(head *ListNode) *ListNode {
	var pre *ListNode
	pos := head
	for pos != nil {
		temp := pos.Next
		pos.Next = pre
		pre = pos
		pos = temp
	}
	return pre
}
```

单链表反转之后，就是要实现每`k`个链表就反转一次，

```go
func reverseKGroup(head *ListNode, k int) *ListNode {
    // 排除特殊情况 
   if k < 2 {
      return head
   }
   // 头节点，头的上面是头发 所以是 hair，保证可以有效返回
   hair := &ListNode{Next: head}
    //  设置前一个节点的指针
   pre := hair
    // 从当前节点开始往下走
   for head != nil {
       //  tail  记录前一个节点，为反转链表做准备 
      tail := pre
		// 遍历链表，每K个节点 反转一次
       for i := 0; i < k; i++ {
         tail = tail.Next
           // 如果最后一组链表不够k个 直接返回，最后一组不进行反转了
         if tail == nil {
            return hair.Next
         }
      }
       //  记录当前节点的下一个节点，防止反转过程中下索引丢失 
      nex := tail.Next
       // 反转链表
      head, tail = rever(head,tail)
       //  反转之后的链表与原链表相连
      pre.Next = head
      tail.Next = nex
       // 重新初始化 pre和tail节点，为下一次反转做准备 
      pre = tail
      head = tail.Next
   }
   return hair.Next
}
// 将head 和 tail 之间的节点进行反转，返回反转之后的节点 为后续链表连接的做准备
func rever(head,tail *ListNode) (*ListNode,*ListNode) {
   prev := tail.Next
   p := head
   for prev != tail {
      next := p.Next
      p.Next = prev
      prev = p
      p = next
   }
   return tail,head
}
```

这个题目其实难度还可以的，思路理一理，很容易想出来的，但是链表的指针变化太多了，所以导致很容易掉坑了，导致链表指针变化出现问题，产生环或者丢失指针。

这个题解是标准答案的题解，我解析了一下，因为我自己写的代码导致我心态崩了，所以只能借鉴一下，看完之后，我发现我真是`nt`，在重新初始化条件的时候修改错了，导致错了，学了一天了，脑袋有点乱，见谅，只能抄官方的然后给出解析。

总结这个题目三步

1. 一个反转链表的变种，返回反转之后的链表头节点和尾节点
2. 反转之后的链表嵌入到原链表中
3. 为下一次链表的反转初始化条件