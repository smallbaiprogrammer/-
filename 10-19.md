#### [211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)

难度中等353收藏分享切换为英文接收动态反馈

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 `WordDictionary` ：

- `WordDictionary()` 初始化词典对象
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true` ；否则，返回 `false` 。`word` 中可能包含一些 `'.'` ，每个 `.` 都可以表示任何一个字母。

 

**示例：**

```
输入：
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
输出：
[null,null,null,null,false,true,true,true]

解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True
```

 

**提示：**

- `1 <= word.length <= 500`
- `addWord` 中的 `word` 由小写英文字母组成
- `search` 中的 `word` 由 '.' 或小写英文字母组成
- 最多调用 `50000` 次 `addWord` 和 `search`



解题思路：

看到这个题，第一想法是根据字符串的长度进行分组，这里就可以直接想到采用`hashMap` + `List`来进行实现


    
```java
class WordDictionary {
    // 初始化数据结构
    Map<Integer, List<String>> map;
    public WordDictionary() {
    	 map = new HashMap<>();
    }
    // 根据字符串长度向数据结构中添加数据
public void addWord(String word) {
    map.putIfAbsent(word.length(), new ArrayList<>());
    map.get(word.length()).add(word);
}

public boolean search(String word) {
    if( !map.containsKey(word.length()) ) 
        return false;
    else{
        // 然后查找数据的时候，进行匹配，如果遇到 '.' 直接跳过
        List<String> list = map.get(word.length());
        for(String str : list){
            char[] c1 = str.toCharArray();
            char[] c2 = word.toCharArray();
            for(int i = 0; i <= c1.length; i++){
                if(i == c1.length) return true;
                if(c2[i] == '.') continue;
                if(c1[i] != c2[i]) break;
            }
        }
    }
    return false;
	}
}
```
这种解法是很容易想到的；你能想到别人也能想到，所有这种解法 太 `low`了，看速度就知道

![image-20211019230224056](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211019230224056.png)

就需要换一个高端点的解法，所以我就仔细思考，费尽心思，绞尽脑汁，然后看了看答案

![](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211019230128889.png)

卧槽原来还有这么nb 的数据结构字典树（其实以前听说过的），也叫前缀树。



## 百度百科

字典树又称单词查找树，[Trie树](https://baike.baidu.com/item/Trie树)，是一种[树形结构](https://baike.baidu.com/item/树形结构/9663807)，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的[字符](https://baike.baidu.com/item/字符)串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

简单来讲就是前缀一样的字符在同一个树上，每个节点存储一个字符或者是每个路径存一个字符

![image-20211019230651836](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211019230651836.png)

比如这颗字典树存储的字符有 `abc bac bbc ca`，注意这个字典树的字树作用顺序是有规律的，类似于`B`树，不知道的有点`b`数  自己去学学。

简单了解这个数据结构，我们发现这个题如果用这个数据结构简直是小母牛怀孕了，牛逼大了。

因为有以下几个点

- 首先是初始化该数据结构或者添加字符串的时候，基本不需要过多资源进行维护
- 其次采用该数据结构可以大大的提示性能，前面的做法需要遍历，这种做法是不需要的

然后可以来进行代码实现

第一部分，因为Java是没有该数据结构的实现的（不是因为Java不行，几乎所有编程语言都没有实现，如果不想写，可以查找第三方依赖库 Java  yyds）

```java
public class Trie {
    // 26 个 字符 
    private Trie[] children;
    // 是否为叶子节点 
    private boolean isEnd;
    public Trie(){
        children = new Trie[26];
        isEnd = false;
    }
    // 定义 插入字符的方法
    public void insert(String word){
        Trie node = this;
        //  向下遍历进行创建
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            int index = c - 'a';
            if (node.children[index] == null){
                node.children[index] = new Trie();
            }
            // 进行递归 
            node = node.children[index];
        }
        node.isEnd = true;
    }
    public Trie[] getChildren(){
        return this.children;
    }

    public boolean isEnd() {
        return isEnd;
    }
}
```

然后进行这个数据结构的实现

```java
class WordDictionary{
    private Trie trie;
    public WordDictionary(){
        trie = new Trie();
    }
    //  基于字符树进行添加
    public void addWord(String word){
        trie.insert(word);
    }
    // 重点 利用搜索进行查找
    public boolean search(String word){
        return dfs(word,0,this.trie);
    }
    // 深度优先搜索
    private boolean dfs(String word,int index,Trie node){
        //  递归的返回条件
        //  字典树查找到叶子节点且模式字符串查找完毕了
        if (index == word.length()){
            return node.isEnd();
        }
        char c = word.charAt(index);
        //  判断如果是当前模式是 字符的时候 不是 .
        //  根据对应字符  进入到相应的 树下进行继续递归
        if (Character.isLetter(c)){
            int childIndex = c - 'a';
            Trie child = node.getChildren()[childIndex];
            //  如果当前字符串 不为空  且后面字符全部通过 递归匹配 返回 true
            if (child != null && dfs(word,index + 1,child)){
                return true;
            }
            //  如果当前字符是点 的时候，就需要对所有非空的字符进行匹配
        }else {
            for (int i = 0; i < 26; i++) {
                Trie child = node.getChildren()[i];
                if (child != null && dfs(word,index + 1,child)){
                    return true;
                }
            }
        }
        return false;
    }
}
```

提交，通过

![image-20211019233914963](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211019233914963.png)

特么的，咋还是这么垃圾，那好我们直接看看前几个是怎么写的，他们速度和允许内存是多少



运行速度排行第一的老哥的代码

```java
class WordDictionary {

    // 树节点定义
    private class TrieNode {
        TrieNode[] path;
        boolean end; // 是否存在以当前字符结尾的word

        public TrieNode() {
            path = new TrieNode[26]; // word中只含有26个小写字符，所以准备26条路
        }
    }


    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }

    public void addWord(String word) {
        if (word == null || word.length() == 0) {
            return;
        }
        // 把word挂到前缀树上
        TrieNode cur = root;
        for (char c: word.toCharArray()) {
            // 五路建路，无路上路
            if (cur.path[c - 'a'] == null) {
                cur.path[c - 'a'] = new TrieNode();
            }
            cur = cur.path[c - 'a']; // 进入下一层
        }
        cur.end = true; // 最后一个word的字符，记得给整个树的这个点给一个end标志
    }

    public boolean search(String word) {
        if (word == null || word.length() == 0) {
            return false;
        }
        return search(word.toCharArray(), 0, root);
    }

    // DFS递归，当前字符：char[i], 当前来到的前缀树节点：cur
    // 返回：[i,...]能否匹配上
    private boolean search(char[] chars, int i, TrieNode cur) {
        if (cur == null) {
            return false;
        }
        char curChar = chars[i];
        // 当前已经是要查找的最后一个字符了
        if (i == chars.length - 1) {
            if (curChar != '.') { // 最后一个字符不是点，需要在前缀树上严格匹配 （有对应的路，并且这条路上有end）
                return cur.path[curChar - 'a'] != null && cur.path[curChar - 'a'].end; //！！！！！！！！！！
            } else { // 最后一个字符不是点，只要存在一条有end的路即可匹配成功
                for (TrieNode node: cur.path) {
                    if (node != null && node.end) {
                        return true;
                    }
                }
                return false; // 说明for找完当前cur的path所有节点，没找到就end，就说明不存在
            }
        }

        // 当前不是最后一个字符，还有不止一个字符需要匹配
        if (curChar != '.') { // 不是点，需要在前缀树上严格匹配 （对所对应的路，并且后续也能匹配上）DFS 递归
            return cur.path[curChar - 'a'] != null && search(chars, i + 1, cur.path[curChar - 'a']);
        }
        // curChar == '.'的情况，只要存在一条路，使得后续可以匹配上即可
        for (TrieNode node: cur.path) { // 所有路都去DFS一下，比较费时，不像上面是明确到 cur.path[curChar - 'a'] 这条路去
            if (search(chars, i + 1, node)) {
                return true;
            }
        }

        return false; // 没找到
    }

}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */
```

其实和我们的代码内容是差不多的，不同的是它用的是内部类，为啥他的运行速度比我的快`20ms`，我们再提交自己的代码试试

![image-20211019234246513](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211019234246513.png)

卧槽了，运行速度瞬间提高，这特么就是玄学

![image-20211019234407731](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211019234407731.png)

其实代码的执行速度本身就是不确定，`leetcode`的运行速度的获取一般是通过最长的那个案例的那个时间，我们编译代码用的又是`leetcode`本身的服务器，编译过程要将代码传输到服务器，得到结果返还到客户端，这取决于服务器的性能，可能某个时间段，访问的人数比较多，速度可能就比较慢。

另外这也说明了运行速度和你的电脑没关系，所以又少了一个甩锅的理由

2021-10-19 23：47  

加油 奥里给  一千五百道题，马上就刷完