#### [335. 路径交叉](https://leetcode-cn.com/problems/self-crossing/)

难度困难

给你一个整数数组 `distance` 。

从 **X-Y** 平面上的点 `(0,0)` 开始，先向北移动 `distance[0]` 米，然后向西移动 `distance[1]` 米，向南移动 `distance[2]` 米，向东移动 `distance[3]` 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。

判断你所经过的路径是否相交。如果相交，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg)

```
输入：distance = [2,1,1,2]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross2-plane.jpg)

```
输入：distance = [1,2,3,4]
输出：false
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross3-plane.jpg)

```
输入：distance = [1,1,1,1]
输出：true
```

 

**提示：**

- `1 <= distance.length <= 105`
- `1 <= distance[i] <= 105`





哇，今天又是一个困难题

### 方案一

首先看看题目，题目说到判断是否重合，我第一时间想到使用`set`结构，

我们可以使用`set`结构存储`(x,y)`节点，然后不断遍历添加节点，先不管结果如何，我们先来试试

```java
public boolean isSelfCrossing(int[] distance) {
        int[][] drivers = {{0,1},{-1,0},{0,-1},{1,0}};
        Set<ArrayList<Integer>> set = new HashSet<>();
        ArrayList<Integer> temp = new ArrayList<>();
        temp.add(0);
        temp.add(0);
        set.add(temp);
        for (int i = 0; i < distance.length; i++) {
            int index = i % 4;
            for (int j = 0; j < distance[i]; j++) {
                // 这里千万要注意引用变化，很大的一个坑
                ArrayList<Integer> list = new ArrayList<>();
                list.add(temp.get(0)+drivers[index][0]);
                list.add(temp.get(1)+drivers[index][1]);
                temp = list;
                if (set.contains(list)){
                    return true;
                }
                set.add(list);
            }
        }
        return false;
    }
```

![image-20211029215234324](../../AppData/Roaming/Typora/typora-user-images/image-20211029215234324.png)

果然倒数第二个案例超时了，这个案例大概有十万个数据，然后数最大不超过10，所有大概遍历的一百万次，所以超时是必然的

### 方案二

#### 既然这个思路是不可以的，那么我们换一个思路，既然点不行，我们可以从一维切换到二维

也是，我们记录线

记录两个点就可以，但是这样很麻烦，因为记录两个点，需要四个参数 `(x1,y1),(x2,y2)`，那是不是可以考虑一下，用一次函数来保持，这样只需要保存两个值，即`k,m`

##### 因为一次函数的表达式`y=kx+b`，这也可以吗 ？？？？？？？？？？？？？？？？？？？？？

当然显然是不可以的，为撒呢，因为一次函数保存的是直线，而且题目中的是线段，所以是不可以的，必须采用两个点的形式。其实也`dark`不必，因为虽然是线段，但是也是特殊的线段，也就是与`x,y`平行的线段，所以可以采用 `x0,y1 y2`的形式或者`x1 x2 ,y0`的形式进行存储

了解了存储形式，那么如何通过两个线段是否相交的呢？，这里注意，是线段，不是直线，小心掉坑

这是数学知识，可以使用映射的形式，将一条线段上的两个端点映射到另一条直线上（单坐标），然后比较就可以发现，这是高中数学的内容，不过多赘述，既然保存和判断方式说完，其他的思路与上面代码类似，不多`bb`了

1. 保存线段的两个端点的横纵坐标
2. 保存线段的方程，线段端点的范围

这种方法的代码实现难度会很大，自行操作

### 方案三

第三种方式就是答案使用的方式，有点想贪心算法的思想

线段交叉一共分为三种情况

1. 第 *i* 次移动和第 i−3 次移动（包含端点）交叉的情况
2. 第 5 次移动和第 1 次移动交叉（重叠）的情况
3. 第 i 次移动和第 *i*−5 次移动（包含端点）交叉的情况，

就这五种情况，只要排除这五种情况，就可以知道这个线段延申过程中是否会产生交叉

```go
func isSelfCrossing(distance []int) bool {
    for i := 3; i < len(distance); i++ {
        // 第 1 类路径交叉的情况
        if distance[i] >= distance[i-2] && distance[i-1] <= distance[i-3] {
            return true
        }

        // 第 2 类路径交叉的情况
        if i == 4 && distance[3] == distance[1] &&
            distance[4] >= distance[2]-distance[0] {
            return true
        }

        // 第 3 类路径交叉的情况
        if i >= 5 && distance[i-3]-distance[i-5] <= distance[i-1] &&
            distance[i-1] <= distance[i-3] &&
            distance[i] >= distance[i-2]-distance[i-4] &&
            distance[i-2] > distance[i-4] {
            return true
        }
    }
    return false
}
```

这种方式的代码实现起来很容器，但是这个过程推导起来十分困难，需要很强的空间思维，用强大的数学知识去证明，其实只要去证明这个就可以了。

答案中采用的数学归纳法，高中知识，自己把握，想要证明就能证明出来

答案中还提到了一种方法们就是反其道而行，不交叉的话一共有那么几种情况，分别推断，最后证明，难点都是证明