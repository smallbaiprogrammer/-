#### [229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)

难度中等504

给定一个大小为 *n* 的整数数组，找出其中所有出现超过 `⌊ n/3 ⌋` 次的元素。

**示例 1：**

```
输入：[3,2,3]
输出：[3]
```

**示例 2：**

```
输入：nums = [1]
输出：[1]
```

**示例 3：**

```
输入：[1,1,1,3,3,2,2,2]
输出：[1,2]
```

 

**提示：**

- `1 <= nums.length <= 5 * 104`
- `-109 <= nums[i] <= 109`

 

首先分析题意，该题的名称为找众数，找出出现次数大于 `n/3`的数，实质上是找出现次数最多的两个数或者一个数，不可能是三个数。

然后基本思路就可以理出来了，使用`map`对每个数的出现次数进行计数

代码如下

```go
func majorityElement(nums []int) []int {
	// 定义返回值
	ans :=[]int{}
	n:= len(nums)
	// 创建 map
	counts:=map[int]int{}
	// 遍历数组  进行计数
	for _, i := range nums {
		counts[i]++
	}
	//  查找出现次数 大于 n/3的两个数
	for key, value := range counts {
		if value > n / 3{
			ans = append(ans,key)
		}
	}
	return ans
}
```

提交，运行通过

![image-20211022233408939](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211022233408939.png)

作为一个资深的程序员，我怎么可能写出这么捞的代码

![image-20211022233521458](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211022233521458.png)

仔细斟酌，这个题难道就这一种解法吗？难道就没有一种碾压群雄的解法。我们再看题![image-20211022233736295](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211022233736295.png)

原来是要求空间复杂度为`o(1)`，我这里的空间复杂度是`O(N)`，

低了，对自己要求低了，怪不得写不出更好的解法，其实在看到这个题的第一眼，我就知道那种方法是最合适的，但是为了低调，没办法

其实这个题，如果想要把空间复杂度降为`O(1)`级别只能采用一种特殊的算法

### 摩尔计数法

关于摩尔计数法

![image-20211022235954443](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211022235954443.png)

论文地址：[festsc.dvi (ou.edu)](https://www.cs.ou.edu/~rlpage/dmtools/mjrty.pdf)

这是一个很成熟的算法，如果要我去证明，还不如杀了我，我只大概了解这个算法原理和使用思路，如果想要详细探讨，可以自己去研究，这个算法在计数方面，求众数等等方面应用非常多，而且这个算法掌握起来还算轻松，所以这个算法最好要记住，主要还是为了可以装XX

![image-20211023000453008](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211023000453008.png)

不墨迹，来写算法实现，同样还是基于`go`语言的

```go
func majorityElement(nums []int) (ans []int) {
	if len(nums) == 0 {
		return
	}
	// 定义两个参选者
	ele1,ele2 := nums[0],nums[0]
	// 定义票数
	vote1,vote2:=0,0
	//  遍历数组，开始统计票数
	for _, num := range nums {
		//  两家计数
		if ele1 == num {
			vote1++
			continue
		}
		if ele2 == num {
			vote2++
			continue
		}
		//  参选者票数不够  自动退出 换当前者位参选者
		if vote1 == 0 {
			ele1 = num
			vote1 = 1
			continue
		}
		if vote2 == 0 {
			ele2 = num
			vote2 = 1
			continue
		}
		// 都没选 票数 被抵消
		vote1 --
		vote2 --
	}
	//  检查  两个票数的超过  n/3
	vote1,vote2 = 0,0
	for _, num := range nums {
		if num == ele1 {
			vote1++
		}
		if num == ele2 {
			vote2++
		}
	}
	if vote1 > len(nums) / 3 {
		ans = append(ans,ele1)
	}
	if vote2 > len(nums) / 3 && ele2 != ele1{
		ans = append(ans,ele2)
	}
	return
}
```

完整复现摩尔计数法的思路，注意一点一定要检查计数超过`n/3`，不然可能会报错，而且两个数千万不要重复

![image-20211023002133703](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211023002133703.png)

