#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

难度中等

编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

 

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= n, m <= 300`
- `-109 <= matrix[i][j] <= 109`
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- `-109 <= target <= 109`



今天的每日一题的，比较简单，最笨的方法直接全遍历一遍，时间复杂度为`O(n^2^)，但是估计肯定会超时

所以采用二分查找的思路，我们从二维数组的的第一行，最右边的位置进行开始遍历

二分查找的条件

1. 如果当前值大于目标值 `target` ，横坐标向左移动
2. 如果当前值小于目标值`target`，纵坐标向下移动
3. 如果当前值等于目标值`target`，返回`true`

如果没有查找到返回 `false`

代码如下，

```go
func searchMatrix(matrix [][]int, target int) bool {
   height := len(matrix)
   width := len(matrix[0])
    // 定义起点 
   i,j := 0,width-1
   for i < height  && j >= 0 {
       //  三个条件 
      num := matrix[i][j]
      if num == target {
         return true
      }else if num > target {
         j--
      }else {
         i++
      }
   }
   return false
}
```

提交代码

![image-20211025211211807](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211025211211807.png)

卧槽，咋这么慢，重试一下

![image-20211025211251208](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211025211251208.png)

卧槽，原来是玄学，上苍保佑 

![image-20211025211343195](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211025211343195.png)

老规矩，今天的每日一题虽然是中等难度的，但是还是太简单了，所以我们再做一个

#### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

难度中等

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

 

**提示：**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

 

**进阶：**你可以使用搜索剪枝的技术来优化解决方案，使其在 `board` 更大的情况下可以更快解决问题？





这个题很明显深度优先搜索，不多`bb`开搞

```go
//  定义全局变量 
var(
   w string
   boards [][]byte
)

func exist(board [][]byte, word string) bool {
   w = word
   boards = board
    //  遍历这个字符串数组，并且以每个字符为启动开始搜索
   for i := 0; i < len(board); i++ {
      for j := 0; j < len(board[i]); j++ {
          // 如果一个搜索成功，说明存在，直接返回true
         if search(i, j, 0) {
            return true
         }
      }
   }
   return false
}
//  搜索，以i,j为起点开始搜索，index表示，当前搜索位的索引
func search(i,j,index int) bool {
    //  如果搜索到字符串最后一位结束，那么直接存在返回true
   if index == len(w) {
      return true
   }
    // 如果i,j越界或者 当前字符值不等于字符串中的字符值，返回false
   if i < 0 || i >= len(boards) || j < 0 || j >= len(boards[0]) || w[index] != boards[i][j] {
      return false
   }
    // 事先将当前字符保存，然后将位置字符修改，防止发生循环递归，
   temp:= boards[i][j]
   boards[i][j] = '.'
   flag := search(i,j+1,index+1) || search(i,j-1,index+1) || search(i+1,j,index+1)||search(i-1,j,index+1)
    // 搜索完成之后，将当前位置的字符值，返还
   boards[i][j] = temp
   return flag
}
```

提交题目

![image-20211025213341355](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211025213341355.png)

一遍过，还可以的的，下面我们尝试一下 题目要求中的剪枝法，当前的深度优先搜索，因为要全部搜索一遍，所以速度很慢，不建议使用，我们尝试一下使用剪枝的方式来优化一下算法

#### 啥是剪枝？

我们都知道搜索算法一般是基于两种方法来进行的（ 深度优先 DFS 和广度优先 BFS ），而这两算法都是基于二叉搜索树的进行的。学过数据结构和算法的都知道二叉搜索树存在很多的分支，很难一次性拿到想要的结果，尤其是当输入参数较大时，二叉搜索树的分支大规模增加的时候，此时，由于搜索过程需要走很多条完全于与结果不相关的路线，所以剪枝思想就出现了。

剪枝一种可以提高搜索算法时间和空间效率的技巧，经过剪枝和其他优化策略优化过的算法在执行效率上远超一般未经剪枝的算法。甚至有些暴力搜索过不了时限的算法，也可以通过各种剪枝+优化大大缩短算法运行时间，成功通过时效限制。由此可见剪枝对于搜索算法的重要性。因此，剪枝对于学习算法和在工作中与算法打交道的人来说都是一类不得不学的知识点。

简单点说，剪枝就是深度优先搜索和广度优先搜索的一种优化方案，减少循环和递归的深度。

然后我们发现，其实在上述过程中，已经做过剪枝优化了，没办法继续优化了，所以这里直接使用上述算法就`ok`了。

今天两道题就是这样了。加油奥里给，明天继续搞。

![image-20211025214243800](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211025214243800.png)

