#### [869. 重新排序得到 2 的幂](https://leetcode-cn.com/problems/reordered-power-of-2/)

难度中等

给定正整数 `N` ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 `true`；否则，返回 `false`。

**示例 1：**

```
输入：1
输出：true
```

**示例 2：**

```
输入：10
输出：false
```

**示例 3：**

```
输入：16
输出：true
```

**示例 4：**

```
输入：24
输出：false
```

**示例 5：**

```
输入：46
输出：true
```

 

**提示：**

1. `1 <= N <= 10^9`



看到这个题，最先注意到 `N`的范围是 `1~10的九次方`，大概范围是在十亿的，32位数有符号数，范围是在负二十亿到正二十亿，包含`2`的幂大概少于32个，所以是常数级的。

题目说到交互可以变为2的幂，也就是说，只要这个数的构成和其中一个2的幂构成是一样的，就证明这个数可以变化为 2 的幂

所以首先需要一个计算各个位数构成的函数的，

```go
func cnt(n int) []int {
   counts := make([]int,10)
   for n > 0 {
      counts[n % 10]++
      n /= 10
   }
   return counts
}
```

写到这里，存储形式其实不一定采用数组的形式，可以采用字符串的形式进行存储，每位以数字存储，如果数字出现次数过多，可以字母存储，这种形式存储，也需要先使用一个数组进行计数，然后转化为字符串形式存储，

```java
func cnt(n int) string {
   var ans strings.Builder
   counts := make([]byte,10)
   for n > 0 {
      counts[n % 10]++
      n /= 10
   }
   for i := 0; i < len(counts); i++ {
      ans.WriteByte(counts[i])
   }
   return ans.String()
}
```

既然想到这里了，我们发现每一位出现的次数不会超过10，按理说有10个数，数字范围是一百亿才可以存储的下，以32位无符号整数的范围是 40 亿，但是此时就是装逼的时候，我们省略一位的计数，这也可以通过其他的位数推断出来，这里我们可以采取省略零的形式，32 位就可以表示

想到这里似乎又发现了新天地，既然要直接计数，为啥不直接这个数各个位进行排序，全部排序之后进行比较，每次比较之前，都对各个位进行排序。

##### 这种节省内存的思路，切记千万要记住，虽然可能短时间用不到，但是一旦用到就是杀手锏级别的优化。

如果一位存储不够怎么办，可以采用两位存，如果32位数不够用怎么办，换64位数，还不够呢，多个数存储，这是一种存储节省内存的思路，因为之前有幸了解过汇编语言，如果一个数字高位不用，就会非常浪费内存。

到这里之后，然后就是这个题目的具体实现了，还是比较简单的，都讲到这里了，后面的还是比较简单的

```go
func countDigits(n int) (cnt [10]int) {
    for n > 0 {
        cnt[n%10]++
        n /= 10
    }
    return
}

var powerOf2Digits = map[[10]int]bool{}

func init() {
    for n := 1; n <= 1e9; n <<= 1 {
        powerOf2Digits[countDigits(n)] = true
    }
}

func reorderedPowerOf2(n int) bool {
    return powerOf2Digits[countDigits(n)]
}

```

提交代码

![image-20211028232532530](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211028232532530.png)

速度，百分百，内存占用有点多，使用内存优化方案，性能会更优



