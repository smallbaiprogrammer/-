#### [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

难度中等

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。

 

**进阶：**你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

 

**示例 1：**

```
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
```

**示例 2：**

```
输入：nums = [-1,0]
输出：[-1,0]
```

**示例 3：**

```
输入：nums = [0,1]
输出：[1,0]
```

**提示：**

- `2 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- 除两个只出现一次的整数外，`nums` 中的其他数字都出现两次



今天这个题目，我们今天直接把类似的题目全部都看完，做这个题目，最直接的思路就是使用`map`进行计数，找出符合要求的那个数字，这种思路很简单，不多`bb`，直接代码

```go
func singleNumber(nums []int) []int {
   count := map[int]int{}
   for i := 0; i < len(nums); i++ {
      count[nums[i]] += 1
   }
   ans := []int{}
   for s, num := range count {
      if  num == 1{
            ans = append(ans,s)
      }
   }
   return ans
}
```

提交代码

![image-20211030213518688](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211030213518688.png)

速度还可以，但是占内存太大了，这种方案是可以解决问题，但是不推荐，不够装逼

![image-20211030214009988](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211030214009988.png)

所以我们采用位运算的方式进行运算，先做一个简单的

#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

难度简单

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

其中一个数组一个数字只出现一次，其他数字出现了两次，我们直接采用位运算，两个相同的数进行异或运算，最终会得到0，一个数和0进行异或运算就会得到这个数本身

所以这个题目，不需要进行计数，直接将所有数全部进行异或运算，就可以得到这个只出现一次的数字，其他的数都出现两次，全部都会被异或运算过滤掉

```go
func singleNumber(nums []int) int {
	n := 0
	for i := 0; i < len(nums); i++ {
		n ^= nums[i]
	}
	return n
}
```

根据计数的思想，其实我们可以得到一个新的思路

我们只需要根据各个位进行计数，32个位分别进行计数，然后将每位对2进行取模，然后转为十进制，就可以得到这个数

```go
func singleNumber(nums []int) int {
    ans := int32(0)
    for i := 0; i < 32; i++ {
        total := int32(0)
        for _, num := range nums {
            total += int32(num) >> i & 1
        }
        if total%2 > 0 {
            ans |= 1 << i
        }
    }
    return int(ans)
}
```

了解了这两种方法，我们来看今天这个题目，显示两种方式都是无法求解的，我们通过通异或，可以得到这两个数字的异或结果，那么如何将这两个数字的异或进行分开呢？

很简单，可以通过为1 的位，然后对数组进行挨个测试就可以得到结果

代码如下

```go
func singleNumber(nums []int) []int {
   n := 0
   for _, num := range nums {
      n ^= num
   }
   
   f := n & -n
   
   ans := make([]int,2)
   //  通过这个异或位，对这个数组进行划分
   for _, num := range nums {
      if f&num > 0 {
         ans[0] ^= num
      }else {
         ans[1] ^= num
      }
   }
   return ans
}
```

`go`中有一点比较麻烦，就是在进行位运算的时候，需要进行控制，因为`go`中`int`很玄妙，这个我自己也没有完全搞明白，提交代码

![image-20211030225132786](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211030225132786.png)

我们发现内存比较节省，但是速度较慢，一般来说算法本来就是二者不可得兼的。

我们再看第三个题目

#### [剑指 Offer II 004. 只出现一次的数字 ](https://leetcode-cn.com/problems/WGki4K/)

难度中等

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

 

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,100]
输出：100
```

 

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

这个题目，显然是无法用之前的方法，进行求解的，但是可以采用32位数组进行计数的形式进行求解

```go
func singleNumber(nums []int) int {
    ans := int32(0)
    for i := 0; i < 32; i++ {
        total := int32(0)
        for _, num := range nums {
            total += int32(num) >> i & 1
        }
        if total%3 > 0 {
            ans |= 1 << i
        }
    }
    return int(ans)
}
```

提交代码

![image-20211030230303943](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211030230303943.png)



### 总结一下

1. `map`计数法，基本方法，可用于所有情况
2. 位运算异或，场景应用优先
3. 32位数组计数法，应用场景也是非常多

了解这三种方法，几乎所有关于计数的题目都可以做出来

