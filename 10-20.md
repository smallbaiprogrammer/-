#### [453. 最小操作次数使数组元w素相等](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/)

难度简单296

给你一个长度为 `n` 的整数数组，每次操作将会使 `n - 1` 个元素增加 `1` 。返回让数组所有元素相等的最小操作次数。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：3
解释：
只需要3次操作（注意每次操作会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```

**示例 2：**

```
输入：nums = [1,1,1]
输出：0
```

 

**提示：**

- `n == nums.length`
- `1 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- 答案保证符合 **32-bit** 整数



这个题的内容虽然是简单的，但是需要一点思考，如果想不出来，做出来还是很难的

就是要理解`n`个数中`n-1`个数加 1 ，相当于 其中一个数减一，这也想就很简单了，我们可以把这些数组比作为木板长度不同的桶，将比最短的木板长的木板砍成和最短长度木板一样长的，就可以做出来了。

所以我们第一步要找出最短的木板的长度是多少，这个很简单的，将数组求和减去最短木板的长度 * 木板的数量，就是结果了

```java
class Solution {
    public int minMoves(int[] nums) {
        //  找到最短木板
        int min = Integer.MAX_VALUE;
        for(int i = 0; i < nums.length ; i++){
            min = Math.min(min,nums[i]);
        }
        //   对数组进行求和同时减去最短木板的长度 
        int res = 0;
        for(int num:nums){
            res+=num;
            res-=min;
        }
        //   得到结果
        return res;
    }
}
```

在`leetcode`的算法题中，有很多的题的思路都是这种逆向思考的，比如 `leetcode` 1503 题 

有一块木板，长度为 n 个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。

当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。

而当蚂蚁在某一时刻 t 到达木板的一端时，它立即从木板上掉下来。

给你一个整数 n 和两个整数数组 left 以及 right 。两个数组分别标识向左或者向右移动的蚂蚁在 t = 0 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。



这个题乍一看，只能采用模拟的方法来做，但是模拟蚂蚁一直变化位置，模拟的话编写代码的难度的非常大。

这里我们可以从这种角度考虑，两只蚂蚁交换位置，我们可以理解为蚂蚁没有交换位置，两只蚂蚁就是直接一直往下走下去了； 两人蚂蚁虽然互换，但是因为每只蚂蚁都是一样的，我们把它当作没换位置一样，这样考虑的话，这个题就容易做了只要找到那一只蚂蚁走的路程最远，就知道最后一只落下去的蚂蚁落下去的时间，代码如下

```java
class Solution {
    public int getLastMoment(int n, int[] left, int[] right) {
        int max = 0;
        for(int i = 0;i <left.length;i++){
            max = Math.max(max,left[i]);
        }
        for(int i=0;i < right.length ; i++){
            max = Math.max(max,n-right[i]);
        }
        return max;
    }
}
```

这个题难度直接从 `middle`变成了 `easy`a
