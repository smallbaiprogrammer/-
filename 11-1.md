#### [575. 分糖果](https://leetcode-cn.com/problems/distribute-candies/)w

难度简单

Alice 有 `n` 枚糖，其中第 `i` 枚糖的类型为 `candyType[i]` 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。

医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 `n / 2` 即可（`n` 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。

给你一个长度为 `n` 的整数数组 `candyType` ，返回： Alice 在仅吃掉 `n / 2` 枚糖的情况下，可以吃到糖的最多种类数。

 

**示例 1：**

```
输入：candyType = [1,1,2,2,3,3]
输出：3
解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。
```

**示例 2：**

```
输入：candyType = [1,1,2,3]
输出：2
解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。
```

**示例 3：**

```
输入：candyType = [6,6,6,6]
输出：1
解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。
```

 

**提示：**

- `n == candyType.length`
- `2 <= n <= 104`
- `n` 是一个偶数
- `-105 <= candyType[i] <= 105`



今天的每日一题，看着题目挺难的，其实很简单的，就是数组去重

```go
func distributeCandies(candyType []int) int {
	count:= map[int]struct{}{}
	for _, num := range candyType {
		_, ok := count[num]
		if !ok {
			count[num] = struct{}{}
		}
	}
	l := len(count)
	if len(candyType)/2 > l {
		return l
	}else {
		return len(candyType)/2
	}
}
```

提交通过

![image-20211101220315386](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211101220315386.png)



除此之外，我们做另一个题目

#### [剑指 Offer II 007. 数组中和为 0 的三个数](https://leetcode-cn.com/problems/1fGaJU/)

难度中等18

给定一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a` ，`b` ，`c` *，*使得 `a + b + c = 0` ？请找出所有和为 `0` 且 **不重复** 的三元组。

 

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**示例 2：**

```
输入：nums = []
输出：[]
```

**示例 3：**

```
输入：nums = [0]
输出：[]
```

 

**提示：**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`



思路就是，三指针，两动一不动，所以就是双指针法，代码如下

```go
func threeSum(nums []int) [][]int {
    var res [][]int
    //  先排序，这样才可以使用双指针方法
    sort.Ints(nums)
    n := len(nums)
    // 选一个定值为  i 
    for i := 0 ; i < n ; i++ {
        // 去重，当 i 前后相同时 直接跳过
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        // 如果最左边的值大于0，三个数的值和一定大于零，直接返回
        if nums[i] > 0 {
            return res
        }
        //  定义双指针  
        left := i + 1
        right := n - 1
       //  第一个值一定为 负值 ，我们以双指针的形式求和 
        target := -nums[i]
        //  双指针
        for left < right {
            //  去重
            if left > i + 1 && nums[left] == nums[left-1] {
                left++
                continue
            }
            //  前两个值大于0，直接返回
            if nums[i] + nums[left] > 0 {
                return res
            }
            // 双指针方法
            if nums[left] + nums[right] > target {
                right --
            }else if nums[left] + nums[right] < target {
                left++
            }else{
                res = append(res,[]int{nums[i],nums[left],nums[right]})
                left++
            }
        }
    }
    return res
}
```

提交代码

![image-20211101223426627](https://typra-pictures.oss-cn-beijing.aliyuncs.com/imgs/image-20211101223426627.png)

思路是这种思路，实现起来可能会有很多种情况